---
title: "Задания по первой лекции"
date: '22 February 2023'
author: 'Elena U'
execute: 
  echo: false
---

Составлены в формате задание - ответ к нему.

Рассчитано на самопроверку: ваша задача написать такой код, чтобы совпал с моим правильным ответом. Плюс есть еще несколько заданий на подумать и вспомнить материал лекции.

Если вдруг найдутся ошибки/опечатки, пишите на почту `e.ubogoeva@alumni.nsu.ru` или в телеграм. Вопросы по заданиям также можно писать на почту или в телеграм, телеграм чуть предпочтительнее.

## Калькулятор

-   Разделите числа `2583`, `5971`, `2946`, `5783` на `7`

```{r}
2583 / 7
5971 / 7
2946 / 7
5783 / 7
```

-   Посчитайте остаток от деления этих же чисел на `7`.

```{r}
2583 %% 7
5971 %% 7
2946 %% 7
5783 %% 7
```

-   А целую часть от деления (числа те же)?\
    Подсказка: справку по арифметическим операторам можно вызвать, набрав например ?\`+\` в консоли или просто погуглить: *оператор целочисленного деления R*

```{r}
2583 %/% 7
5971 %/% 7
2946 %/% 7
5783 %/% 7
```

-   Посчитайте квадратный корень из числа 289 двумя разными способами

```{r}
sqrt(289)
289 ^ 0.5
```

-   Посчитайте логарифм по основанию `7` от числа `96889010407`

```{r}
log(96889010407, 7)
```

-   Теперь натуральный логарифм от числа `10`, результат умножить на `6`

```{r}
log(10) * 6
```

## Работа с векторами

-   Создайте вектор из чисел 5, 203, 11

```{r}
c(5, 203, 11)
```

-   Создайте вектор из чисел от 314 до 335

```{r}
314:335
```

-   Создайте вектор чисел от 20 до 2. Подсказка: оператор `:` работает и для создания последовательностей с шагом -1/

```{r}
20:2
```

-   Создайте вектор чисел от 20 до 2 с шагом -2.

```{r}
seq(20, 2, -2)
```

-   Создайте вектор, состоящий из двадцати единиц

    ```{r}
    rep(1, 20)
    ```

-   Создайте вектор 1 1 1 2 2 2 3 3 3. Подсказка: чтобы узнать как это можно сделать, посмотрите справку функции `rep()`

    ```{r}
    rep(1:3, each = 3)
    ```

-   А теперь вектор 1 1 2 2 3 3 1 1 2 2 3 3 1 1 2 2 3 3 (если что непонятно - смотрим справку и гуглим)

    ```{r}
    rep(1:3, each = 2, times = 3)
    ```

## Логические операторы

-   Проверьте на равенство: остаток от деления 257 на 6 и число 5

```{r}
5 == 257 %% 6
```

-   Проверьте на равенство число 2 и квадратный корень из 2 в квадрате.\
    Ответ убил:

    ```{r}
    2 == sqrt(2) ^ 2
    ```

    ```{r}
    #| echo: true
    #| output: false
    2 == sqrt(2) ^ 2
    ```

    Почему это произошло, можно почитать [здесь](https://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-doesn_0027t-R-think-these-numbers-are-equal_003f). Такой прикол существует не только в R, а характерен для любого языка программирования, поскольку дробные числа в компьютере хранятся с ограниченной (хоть и достаточно большой) точностью. Для проверки на равенство такого рода можно использовать функцию `all.equal()`.

    ```{r}
    #| echo: true
    all.equal(2, sqrt(2) ^ 2)
    ```

    ::: callout-note
    Все дело в том, что числа в компьютере записываются в виде степеней двойки.
    :::

-   Сколько чисел, делящихся на 3 без остатка, в векторе чисел от 1 до 80?

    ```{r}
    sum(1:80 %% 3 == 0)
    ```

## Индексация векторов

-   Создайте вектор x, состоящий из чисел с 2 до 20 с шагом 2. Извлеките 2, 5, 7 элемент

```{r}
x <- seq(2, 20, 2)
x[c(2, 5, 7)]
```

-   Создайте вектор x, состоящий из чисел с 2 до 20 с шагом 2. Извлеките каждый третий элемент.

    ```{r}
    x <- seq(2, 20, 2)
    x[seq(3, length(x), 3)]
    ```

-   Индесация по условию. Извлеките все числа, кратные 9, в векторе чисел от 1 до 100.

    ```{r}
    x <- 1:100
    x[x %% 9 == 0]
    ```

-   Извлеките все числа, больше или равные нулю в векторе -4 -2 0 2 4

    ```{r}
    x <- seq(-4, 4, 2)
    x[x >= 0]
    ```

## Приведение типов

-   Какой будет тип у вектора `c(TRUE, 2, 'gene')`? И почему?

-   Вспомните, в каком порядке должно идти приведение типов.

-   Какими функциями можно превратить вектор в нужный тип?

## Пропущенные значения

-   Уберите пропущенные значения из вектора\
    `missed_values <- c(NA, 1:3, NA, 7, 10, NA, NA, NA, 8, 5, 7)`

    ```{r}
    missed_values <- c(NA, 1:3, NA, 7, 10, NA, NA, NA, 8, 5, 7)
    missed_values[!is.na(missed_values)]
    ```

-   Посчитайте среднее в этом векторе двумя разными способами

    ```{r}
    mean(missed_values[!is.na(missed_values)])
    mean(missed_values, na.rm = TRUE)
    ```

-   Почему при сравнении `NA == NA` получается `NA`?

-   Чем плохи пропущенные значения?
